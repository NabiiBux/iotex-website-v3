import {
  $mobx,
  EMPTY_OBJECT,
  FlowCancellationError,
  MobXGlobals,
  ObservableMap,
  ObservableSet,
  Reaction,
  _endAction,
  _extends,
  _isObservable,
  _startAction,
  action,
  addHiddenProp,
  allowStateChangesEnd,
  allowStateChangesStart,
  allowStateReadsEnd,
  allowStateReadsStart,
  asObservableObject,
  autoAction,
  autorun,
  comparer,
  computed,
  configure,
  createAction,
  createAtom,
  createSchedulerFromOptions,
  die,
  endBatch,
  extendObservable,
  flow,
  getAdministration,
  getAtom,
  getDebugName,
  getDependencyTree,
  getNextId,
  globalState,
  isAction,
  isComputedValue,
  isFlow,
  isFunction,
  isObservable,
  isObservableArray,
  isObservableMap,
  isObservableObject,
  isObservableSet,
  isObservableValue,
  isPlainObject,
  isStringish,
  keysSymbol,
  makeObservable,
  objectPrototype,
  observable,
  onBecomeObserved,
  onBecomeUnobserved,
  override,
  ownKeys,
  runInAction,
  spy,
  startBatch,
  trace,
  transaction,
  untracked
} from "./chunk.Z6HAY5KM.js";

// node_modules/mobx/dist/mobx.esm.js
function allowStateChanges(allowStateChanges2, func) {
  var prev = allowStateChangesStart(allowStateChanges2);
  try {
    return func();
  } finally {
    allowStateChangesEnd(prev);
  }
}
function isComputingDerivation() {
  return globalState.trackingDerivation !== null;
}
var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
function getGlobalState() {
  return globalState;
}
function resetGlobalState() {
  var defaultGlobals = new MobXGlobals();
  for (var key in defaultGlobals) {
    if (persistentKeys.indexOf(key) === -1)
      globalState[key] = defaultGlobals[key];
  }
  globalState.allowStateChanges = !globalState.enforceActions;
}
function hasObservers(observable2) {
  return observable2.observers_ && observable2.observers_.size > 0;
}
function getObservers(observable2) {
  return observable2.observers_;
}
function onReactionError(handler) {
  globalState.globalReactionErrorHandlers.push(handler);
  return function() {
    var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
    if (idx >= 0)
      globalState.globalReactionErrorHandlers.splice(idx, 1);
  };
}
function reaction(expression, effect, opts) {
  var _opts$name2;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (true) {
    if (!isFunction(expression) || !isFunction(effect))
      die("First and second argument to reaction should be functions");
    if (!isPlainObject(opts))
      die("Third argument of reactions should be an object");
  }
  var name = (_opts$name2 = opts.name) != null ? _opts$name2 : true ? "Reaction@" + getNextId() : "Reaction";
  var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
  var runSync = !opts.scheduler && !opts.delay;
  var scheduler = createSchedulerFromOptions(opts);
  var firstTime = true;
  var isScheduled = false;
  var value;
  var oldValue = void 0;
  var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
  var r = new Reaction(name, function() {
    if (firstTime || runSync) {
      reactionRunner();
    } else if (!isScheduled) {
      isScheduled = true;
      scheduler(reactionRunner);
    }
  }, opts.onError, opts.requiresObservable);
  function reactionRunner() {
    isScheduled = false;
    if (r.isDisposed_)
      return;
    var changed = false;
    r.track(function() {
      var nextValue = allowStateChanges(false, function() {
        return expression(r);
      });
      changed = firstTime || !equals(value, nextValue);
      oldValue = value;
      value = nextValue;
    });
    if (firstTime && opts.fireImmediately)
      effectAction(value, oldValue, r);
    else if (!firstTime && changed)
      effectAction(value, oldValue, r);
    firstTime = false;
  }
  r.schedule_();
  return r.getDisposer_();
}
function wrapErrorHandler(errorHandler, baseFn) {
  return function() {
    try {
      return baseFn.apply(this, arguments);
    } catch (e) {
      errorHandler.call(this, e);
    }
  };
}
function getObserverTree(thing, property) {
  return nodeToObserverTree(getAtom(thing, property));
}
function nodeToObserverTree(node) {
  var result = {
    name: node.name_
  };
  if (hasObservers(node))
    result.observers = Array.from(getObservers(node)).map(nodeToObserverTree);
  return result;
}
function isFlowCancellationError(error) {
  return error instanceof FlowCancellationError;
}
function flowResult(result) {
  return result;
}
function interceptReads(thing, propOrHandler, handler) {
  var target;
  if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) {
    target = getAdministration(thing);
  } else if (isObservableObject(thing)) {
    if (!isStringish(propOrHandler))
      return die("InterceptReads can only be used with a specific property, not with an object in general");
    target = getAdministration(thing, propOrHandler);
  } else if (true) {
    return die("Expected observable map, object or array as first array");
  }
  if (target.dehancer !== void 0)
    return die("An intercept reader was already established");
  target.dehancer = typeof propOrHandler === "function" ? propOrHandler : handler;
  return function() {
    target.dehancer = void 0;
  };
}
function intercept(thing, propOrHandler, handler) {
  if (isFunction(handler))
    return interceptProperty(thing, propOrHandler, handler);
  else
    return interceptInterceptable(thing, propOrHandler);
}
function interceptInterceptable(thing, handler) {
  return getAdministration(thing).intercept_(handler);
}
function interceptProperty(thing, property, handler) {
  return getAdministration(thing, property).intercept_(handler);
}
function _isComputed(value, property) {
  if (property !== void 0) {
    if (isObservableObject(value) === false)
      return false;
    if (!value[$mobx].values_.has(property))
      return false;
    var atom = getAtom(value, property);
    return isComputedValue(atom);
  }
  return isComputedValue(value);
}
function isComputed(value) {
  if (arguments.length > 1)
    return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
  return _isComputed(value);
}
function isComputedProp(value, propName) {
  if (!isStringish(propName))
    return die("isComputed expected a property name as second argument");
  return _isComputed(value, propName);
}
function isObservableProp(value, propName) {
  if (!isStringish(propName))
    return die("expected a property name as second argument");
  return _isObservable(value, propName);
}
function keys(obj) {
  if (isObservableObject(obj)) {
    return obj[$mobx].keys_();
  }
  if (isObservableMap(obj) || isObservableSet(obj)) {
    return Array.from(obj.keys());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(_, index) {
      return index;
    });
  }
  die(5);
}
function values(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key) {
      return obj[key];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key) {
      return obj.get(key);
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.values());
  }
  if (isObservableArray(obj)) {
    return obj.slice();
  }
  die(6);
}
function entries(obj) {
  if (isObservableObject(obj)) {
    return keys(obj).map(function(key) {
      return [key, obj[key]];
    });
  }
  if (isObservableMap(obj)) {
    return keys(obj).map(function(key) {
      return [key, obj.get(key)];
    });
  }
  if (isObservableSet(obj)) {
    return Array.from(obj.entries());
  }
  if (isObservableArray(obj)) {
    return obj.map(function(key, index) {
      return [index, key];
    });
  }
  die(7);
}
function set(obj, key, value) {
  if (arguments.length === 2 && !isObservableSet(obj)) {
    startBatch();
    var _values = key;
    try {
      for (var _key in _values) {
        set(obj, _key, _values[_key]);
      }
    } finally {
      endBatch();
    }
    return;
  }
  if (isObservableObject(obj)) {
    obj[$mobx].set_(key, value);
  } else if (isObservableMap(obj)) {
    obj.set(key, value);
  } else if (isObservableSet(obj)) {
    obj.add(key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number")
      key = parseInt(key, 10);
    if (key < 0)
      die("Invalid index: '" + key + "'");
    startBatch();
    if (key >= obj.length)
      obj.length = key + 1;
    obj[key] = value;
    endBatch();
  } else
    die(8);
}
function remove(obj, key) {
  if (isObservableObject(obj)) {
    obj[$mobx].delete_(key);
  } else if (isObservableMap(obj)) {
    obj["delete"](key);
  } else if (isObservableSet(obj)) {
    obj["delete"](key);
  } else if (isObservableArray(obj)) {
    if (typeof key !== "number")
      key = parseInt(key, 10);
    obj.splice(key, 1);
  } else {
    die(9);
  }
}
function has(obj, key) {
  if (isObservableObject(obj)) {
    return obj[$mobx].has_(key);
  } else if (isObservableMap(obj)) {
    return obj.has(key);
  } else if (isObservableSet(obj)) {
    return obj.has(key);
  } else if (isObservableArray(obj)) {
    return key >= 0 && key < obj.length;
  }
  die(10);
}
function get(obj, key) {
  if (!has(obj, key))
    return void 0;
  if (isObservableObject(obj)) {
    return obj[$mobx].get_(key);
  } else if (isObservableMap(obj)) {
    return obj.get(key);
  } else if (isObservableArray(obj)) {
    return obj[key];
  }
  die(11);
}
function observe(thing, propOrCb, cbOrFire, fireImmediately) {
  if (isFunction(cbOrFire))
    return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);
  else
    return observeObservable(thing, propOrCb, cbOrFire);
}
function observeObservable(thing, listener, fireImmediately) {
  return getAdministration(thing).observe_(listener, fireImmediately);
}
function observeObservableProperty(thing, property, listener, fireImmediately) {
  return getAdministration(thing, property).observe_(listener, fireImmediately);
}
function cache(map, key, value) {
  map.set(key, value);
  return value;
}
function toJSHelper(source, __alreadySeen) {
  if (source == null || typeof source !== "object" || source instanceof Date || !isObservable(source))
    return source;
  if (isObservableValue(source))
    return toJSHelper(source.get(), __alreadySeen);
  if (__alreadySeen.has(source)) {
    return __alreadySeen.get(source);
  }
  if (isObservableArray(source)) {
    var res = cache(__alreadySeen, source, new Array(source.length));
    source.forEach(function(value, idx) {
      res[idx] = toJSHelper(value, __alreadySeen);
    });
    return res;
  }
  if (isObservableSet(source)) {
    var _res = cache(__alreadySeen, source, new Set());
    source.forEach(function(value) {
      _res.add(toJSHelper(value, __alreadySeen));
    });
    return _res;
  }
  if (isObservableMap(source)) {
    var _res2 = cache(__alreadySeen, source, new Map());
    source.forEach(function(value, key) {
      _res2.set(key, toJSHelper(value, __alreadySeen));
    });
    return _res2;
  } else {
    var _res3 = cache(__alreadySeen, source, {});
    source[$mobx].ownKeys_().forEach(function(key) {
      if (objectPrototype.propertyIsEnumerable.call(source, key)) {
        _res3[key] = toJSHelper(source[key], __alreadySeen);
      }
    });
    return _res3;
  }
}
function toJS(source, options) {
  if (options)
    die("toJS no longer supports options");
  return toJSHelper(source, new Map());
}
function when(predicate, arg1, arg2) {
  if (arguments.length === 1 || arg1 && typeof arg1 === "object")
    return whenPromise(predicate, arg1);
  return _when(predicate, arg1, arg2 || {});
}
function _when(predicate, effect, opts) {
  var timeoutHandle;
  if (typeof opts.timeout === "number") {
    timeoutHandle = setTimeout(function() {
      if (!disposer[$mobx].isDisposed_) {
        disposer();
        var error = new Error("WHEN_TIMEOUT");
        if (opts.onError)
          opts.onError(error);
        else
          throw error;
      }
    }, opts.timeout);
  }
  opts.name = true ? opts.name || "When@" + getNextId() : "When";
  var effectAction = createAction(true ? opts.name + "-effect" : "When-effect", effect);
  var disposer = autorun(function(r) {
    var cond = allowStateChanges(false, predicate);
    if (cond) {
      r.dispose();
      if (timeoutHandle)
        clearTimeout(timeoutHandle);
      effectAction();
    }
  }, opts);
  return disposer;
}
function whenPromise(predicate, opts) {
  if (opts && opts.onError)
    return die("the options 'onError' and 'promise' cannot be combined");
  var cancel;
  var res = new Promise(function(resolve, reject) {
    var disposer = _when(predicate, resolve, _extends({}, opts, {
      onError: reject
    }));
    cancel = function cancel2() {
      disposer();
      reject("WHEN_CANCELLED");
    };
  });
  res.cancel = cancel;
  return res;
}
function makeAutoObservable(target, overrides, options) {
  if (true) {
    if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target)))
      die("'makeAutoObservable' can only be used for classes that don't have a superclass");
    if (isObservableObject(target))
      die("makeAutoObservable can only be used on objects not already made observable");
  }
  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }
  var adm = asObservableObject(target, options)[$mobx];
  if (!target[keysSymbol]) {
    var proto = Object.getPrototypeOf(target);
    var keys2 = new Set([].concat(ownKeys(target), ownKeys(proto)));
    keys2["delete"]("constructor");
    keys2["delete"]($mobx);
    addHiddenProp(proto, keysSymbol, keys2);
  }
  startBatch();
  try {
    target[keysSymbol].forEach(function(key) {
      return adm.make_(key, !overrides ? true : key in overrides ? overrides[key] : true);
    });
  } finally {
    endBatch();
  }
  return target;
}
export {
  $mobx,
  FlowCancellationError,
  ObservableMap,
  ObservableSet,
  Reaction,
  allowStateChanges as _allowStateChanges,
  runInAction as _allowStateChangesInsideComputed,
  allowStateReadsEnd as _allowStateReadsEnd,
  allowStateReadsStart as _allowStateReadsStart,
  autoAction as _autoAction,
  _endAction,
  getAdministration as _getAdministration,
  getGlobalState as _getGlobalState,
  interceptReads as _interceptReads,
  isComputingDerivation as _isComputingDerivation,
  resetGlobalState as _resetGlobalState,
  _startAction,
  action,
  autorun,
  comparer,
  computed,
  configure,
  createAtom,
  entries,
  extendObservable,
  flow,
  flowResult,
  get,
  getAtom,
  getDebugName,
  getDependencyTree,
  getObserverTree,
  has,
  intercept,
  isAction,
  isObservableValue as isBoxedObservable,
  isComputed,
  isComputedProp,
  isFlow,
  isFlowCancellationError,
  isObservable,
  isObservableArray,
  isObservableMap,
  isObservableObject,
  isObservableProp,
  isObservableSet,
  keys,
  makeAutoObservable,
  makeObservable,
  observable,
  observe,
  onBecomeObserved,
  onBecomeUnobserved,
  onReactionError,
  override,
  reaction,
  remove,
  runInAction,
  set,
  spy,
  toJS,
  trace,
  transaction,
  untracked,
  values,
  when
};
//# sourceMappingURL=mobx.js.map
